!    Go-PERMDIST
!    Copyright (C) 2017  Matthew Griffiths
!
!    This program is free software; you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation; either version 2 of the License, or
!    (at your option) any later version.
!
!    This program is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU General Public License for more details.
!
!    You should have received a copy of the GNU General Public License along
!    with this program; if not, write to the Free Software Foundation, Inc.,
!    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

!***********************************************************************
! GOPERMDIST MODULE
!***********************************************************************

! Subroutines:
!
!    BNB_ALIGN(COORDSB,COORDSA,NATOMS,DEBUGT,NBOXLX,NBOXLY,NBOXLZ,NBULKT,DISTANCE,DIST2,RMATBEST,NSTEPS)

!    RUN(NITER, FORCE, IPRINT, BESTUPPER)

!    ADDNODE(VECTOR,WIDTH,IDNUM,BESTUPPER,FORCE,LOWERBOUND,UPPERBOUND)

!    BRANCH(VECTOR,WIDTH,IDNUM,BESTUPPER,FORCE)

!    CALCBOUNDS(LOWERBOUND,UPPERBOUND,VECTOR,WIDTH,IDNUM,BESTUPPER,FORCE)

!    FINDPERMVAL(PERM, NATOMS, MATVALS, DINVIDX, MAXNEI, NPERMGROUP, BEST)

!    INVPAIRDISTIDX(DUMMYIDX, DINVIDX, NATOMS, MAXNEI, NPERMGROUP)

!    PERMNEARESTNEIGHBOURDISTS(NDISTS,NIDX,NATOMS,MAXNEI,NEARI,NEARD,NPERMGROUP)

!    NEARESTNEIGHBOURDISTS(CC, KK, N, MAXNEI, IDX, DISTS)

!    QUEUEPUT(LOWERBOUND, UPPERBOUND, VECTOR, WIDTH, NITER, IDNUM)

!    INITIALISE(COORDSB,COORDSA,NATOMS,NBOXLX,NBOXLY,NBOXLZ,NBULKT)

!    SETNATOMS(NEWNATOMS)

!    SETPERM(NEWNATOMS, NEWPERMGROUP, NEWNPERMSIZE)

!    TRANSFORM(NEWCOORDSA, NATOMS, VECTOR, IDNUM)

!    ANGLEAXIS2MAT(VECTOR,RMAT)

!    MAT2ANGLEAXIS(VECTOR, RMAT)

!    REALLOCATEARRAYS(NATOMS, NUMSTRUCTS, BULKT)

!    SETCLUSTER(INVERT)

!    SETBULK(INVERT)

! Functions:
!    BOUNDROTDISTANCE(D2,COSW,SINW,RA,RB)

!    QUEUELEN()

!***********************************************************************

INCLUDE "commons.f90"
INCLUDE "alignutils.f90"

MODULE GOPERMDIST

!USE COMMONS, ONLY : PERMGROUP, NPERMSIZE, NPERMGROUP, BESTPERM, MYUNIT, &
! & NSETS, SETS, OHCELLT, PERMINVOPT, PERMDIST, PERMOPT, BOXLX, BOXLY, BOXLZ
USE ALIGNUTILS, ONLY : PERMGROUP, NPERMSIZE, NPERMGROUP, BESTPERM, MYUNIT, &
 & NSETS, SETS, DEBUG, OHCELLT, PERMINVOPT, NOINVERSION, BOXLX, BOXLY, BOXLZ, &
 & TWOD, SAVECOORDS, NSTORED
USE PRIORITYQUEUE, ONLY: QUEUE

IMPLICIT NONE

INTEGER, SAVE :: NATOMS, NCALC, NLAP, NQUENCH, NBAD
INTEGER, SAVE :: PMAXNEI = 60 ! Number of nearest neighbours to store
INTEGER, SAVE :: PRINTRATE = 1
DOUBLE PRECISION, PARAMETER :: PSCALE = 1.D6 ! Scale for linear assignment problem
DOUBLE PRECISION, PARAMETER :: PI = 3.141592653589793D0
! Absolute Tolerance, Relative Tolerance, Relative Tolerance for MINPERMDIST quench
DOUBLE PRECISION, SAVE :: ATOL=1D-8, RTOL=1D-1, MPRTOL=1.D-1

DOUBLE PRECISION, SAVE :: LVECS(3,0:8), FVECS(4,6), TWODVECS(3,0:4)

DOUBLE PRECISION, SAVE :: CMAX,CMAY,CMAZ,CMBX,CMBY,CMBZ
DOUBLE PRECISION, SAVE :: DUMMYRMAT(3,3), TRMAT(3,3), DUMMYDISP(3)
LOGICAL, SAVE :: FORCEASSIGNMENT=.FALSE.

! Module saves periodic conditions variables
LOGICAL, SAVE :: BULKT
LOGICAL, SAVE :: OHCELLTSAVE
DOUBLE PRECISION, SAVE :: BOXVEC(3), DISPBEST(3)

! Arrays to store target and candidate structures and best found structures
DOUBLE PRECISION, SAVE, ALLOCATABLE  :: SAVECOORDSA(:,:),PERMCOORDSB(:,:,:), &
 & SAVECOORDSB(:), BESTCOORDSA(:,:), BESTRMAT(:,:,:), BESTDISP(:,:)
DOUBLE PRECISION, SAVE, ALLOCATABLE  :: SAVERA(:,:), SAVERB(:)
INTEGER, SAVE, ALLOCATABLE :: BESTITERS(:), BESTPERMS(:,:)
INTEGER, SAVE :: BESTID, BESTITER


! Used when calculating Boundsin CALCBOUNDS
DOUBLE PRECISION :: BRANCHVECS(3,8)
DOUBLE PRECISION, SAVE, ALLOCATABLE  :: DUMMYCOORDSA(:,:), PDUMMYND(:)
! Arrays of distances and nearest neighbour distances

DOUBLE PRECISION, SAVE, ALLOCATABLE :: DUMMYDISTS(:,:), DUMMYNEARDISTS(:)

DOUBLE PRECISION, SAVE, ALLOCATABLE :: DUMMYDISPS(:,:,:)
! Arrays of bounded distances and nearest neighbour distances
DOUBLE PRECISION, SAVE, ALLOCATABLE :: DUMMYLDISTS(:,:), DUMMYNEARLDISTS(:), &
 & DUMMYLDISTS2(:,:), DUMMYDOTDISP(:,:,:)

INTEGER, SAVE, ALLOCATABLE :: DUMMYIDX(:,:), DINVIDX(:,:), DUMMYNEARIDX(:)
INTEGER, SAVE, ALLOCATABLE :: INVPERMGROUP(:)

! Used when solving assignment problem
DOUBLE PRECISION, SAVE, ALLOCATABLE :: PDUMMYA(:), PDUMMYB(:), DUMMYA(:), &
    & DUMMYB(:), XBESTA(:), XBESTASAVE(:)

INTEGER, SAVE, ALLOCATABLE :: NEWPERM(:), LPERM(:), PERMBEST(:)

TYPE(QUEUE) :: Q

DATA LVECS / &
 &  0.0D0,  0.0D0,  0.0D0, &
 &  1.0D0,  1.0D0,  1.0D0, &
 &  1.0D0,  1.0D0, -1.0D0, &
 &  1.0D0, -1.0D0,  1.0D0, &
 &  1.0D0, -1.0D0, -1.0D0, &
 & -1.0D0,  1.0D0,  1.0D0, &
 & -1.0D0,  1.0D0, -1.0D0, &
 & -1.0D0, -1.0D0,  1.0D0, &
 & -1.0D0, -1.0D0, -1.0D0 /

DATA FVECS / &
 &  1.0D0,  1.0D0,  1.0D0,  1.0D0, &
 &  1.0D0,  1.0D0, -1.0D0, -1.0D0, &
 &  1.0D0, -1.0D0,  1.0D0, -1.0D0, &
 & -1.0D0, -1.0D0, -1.0D0, -1.0D0, &
 & -1.0D0, -1.0D0,  1.0D0,  1.0D0, &
 & -1.0D0,  1.0D0, -1.0D0,  1.0D0 /

DATA TWODVECS / &
 &  0.0D0,  0.0D0,  0.0D0, &
 &  1.0D0,  1.0D0,  0.0D0, &
 &  1.0D0, -1.0D0,  0.0D0, &
 & -1.0D0,  1.0D0,  0.0D0, &
 & -1.0D0, -1.0D0,  0.0D0 /

! Private so that module works with f2py and static linking to priorityqueue.f90
PRIVATE :: Q

CONTAINS

SUBROUTINE BNB_ALIGN(COORDSB,COORDSA,NATOMS,DEBUGT,NBOXLX,NBOXLY,NBOXLZ,NBULKT, &
    & DISTANCE,DIST2,RMATBEST,NSTEPS)

IMPLICIT NONE

LOGICAL, INTENT(IN) :: NBULKT, DEBUGT
INTEGER, INTENT(IN) :: NATOMS, NSTEPS
DOUBLE PRECISION, INTENT(INOUT) :: COORDSB(3*NATOMS), COORDSA(3*NATOMS)
DOUBLE PRECISION, INTENT(IN) :: NBOXLX, NBOXLY, NBOXLZ

DOUBLE PRECISION, INTENT(OUT) :: DISTANCE, DIST2, RMATBEST(3,3)

DOUBLE PRECISION VECTOR(3), WIDTH, BESTUPPER, LOWERBOUND, UPPERBOUND
INTEGER IDNUM


! Allocating and assigning to temporary arrays
CALL INITIALISE(COORDSB, COORDSA, NATOMS, NBOXLX, NBOXLY, NBOXLZ, NBULKT)

! Setting parameters
DEBUG = DEBUGT
NSTORED = 0 ! For saving coordinates
BESTUPPER = HUGE(1.D0)
VECTOR(:) = 0.D0
IF(BULKT) THEN
    WIDTH = MAX(NBOXLX, NBOXLY, NBOXLZ)
ELSE
    WIDTH = 2.D0 * PI
END IF

! Initialise BnB nodes
IDNUM = 1
! Standard search region
CALL ADDNODE(VECTOR,WIDTH,IDNUM,BESTUPPER,.TRUE.,LOWERBOUND,UPPERBOUND)

IF(BULKT.AND.OHCELLT) THEN
    ! Adding all 48 octahedral symmetries
    DO IDNUM=2,48
        CALL ADDNODE(VECTOR,WIDTH,IDNUM,BESTUPPER,.TRUE.,LOWERBOUND,UPPERBOUND)
    END DO
ELSE IF(PERMINVOPT) THEN
    ! Adding permutation inversion isomer
    CALL ADDNODE(VECTOR,WIDTH,2,BESTUPPER,.TRUE.,LOWERBOUND,UPPERBOUND)
END IF

! Perform BnB
CALL RUN(NSTEPS,FORCEASSIGNMENT,PRINTRATE,BESTUPPER)

! Return results
COORDSB(:) = SAVECOORDSB(:)
COORDSA(:) = BESTCOORDSA(:,BESTID)

DISTANCE = BESTUPPER
DIST2 = DISTANCE**2

IF (NBULKT) THEN
	DISPBEST = BESTDISP(:,BESTID)
ELSE
    RMATBEST = BESTRMAT(:,:,BESTID)
ENDIF

BESTPERM = BESTPERMS(:,BESTID)

END SUBROUTINE BNB_ALIGN

SUBROUTINE RUN(NITER, FORCE, IPRINT, BESTUPPER)

USE ALIGNUTILS, ONLY : PRINTDISTANCES
IMPLICIT NONE

INTEGER, INTENT(IN) :: NITER, IPRINT
LOGICAL, INTENT(IN) :: FORCE
DOUBLE PRECISION, INTENT(INOUT) :: BESTUPPER

DOUBLE PRECISION LOWERBOUND, UPPERBOUND, VECTOR(3), WIDTH
INTEGER I,IDNUM,NODEITER

DO I=1,NITER

    CALL QUEUEGET(LOWERBOUND, UPPERBOUND, VECTOR, WIDTH, NODEITER, IDNUM)

    IF(DEBUG.AND.(IPRINT.GT.0).AND.(MOD(I,IPRINT).EQ.0)) THEN
        WRITE(MYUNIT,'(A)') &
         & "gopermdist> -----------------STATUS UPDATE----------------"
        WRITE(MYUNIT,'(A,I16)') &
         & "gopermdist> iteration  number           = ", I
        WRITE(MYUNIT,'(A,G20.6)') &
         & "gopermdist> lowest upper bound so far   = ", BESTUPPER
        WRITE(MYUNIT,'(A,G20.6)') &
         & "gopermdist> highest lower bound so far  = ", LOWERBOUND
        WRITE(MYUNIT,'(A,I16)') &
         & "gopermdist> total calculations so far   = ", NCALC
        WRITE(MYUNIT,'(A,I16)') &
         & "gopermdist> queue length                = ", QUEUELEN()
        WRITE(MYUNIT,'(A)') &
         & "gopermdist> ----------------------------------------------"
    ENDIF

    CALL BRANCH(VECTOR,WIDTH,IDNUM,BESTUPPER,FORCE)

    IF(QUEUELEN().LE.0) THEN
        IF(DEBUG) WRITE(MYUNIT,'(A)') &
             & "gopermdist> priority queue empty, stopping"
    END IF

    IF((QUEUELEN().LE.0).OR.((LOWERBOUND).GT.(BESTUPPER - RTOL*BESTUPPER - ATOL))) THEN
        IF(DEBUG) THEN
            WRITE(MYUNIT,'(A)') &
             & "gopermdist> -------------------SUCCESS--------------------"
            WRITE(MYUNIT,'(A,G20.6)') &
             & "gopermdist> converged on minimum RMSD   = ", BESTUPPER
            WRITE(MYUNIT,'(A,I16)') &
             & "gopermdist> total calculations          = ", NCALC
            WRITE(MYUNIT,'(A,I16)') &
             & "gopermdist> found best on iteration     = ", BESTITER
            WRITE(MYUNIT,'(A,I16)') &
             & "gopermdist> best structure              = ", BESTID
            WRITE(MYUNIT,'(A)') &
             & "gopermdist> -------------------SUCCESS--------------------"
        END IF
        EXIT
    END IF

END DO

IF (DEBUG.AND.SAVECOORDS) CALL PRINTDISTANCES()

END SUBROUTINE

SUBROUTINE ADDNODE(VECTOR,WIDTH,IDNUM,BESTUPPER,FORCE,LOWERBOUND,UPPERBOUND)

USE ALIGNUTILS, ONLY : ITERATIVEALIGN

IMPLICIT NONE
DOUBLE PRECISION, INTENT(IN) :: VECTOR(3), WIDTH
DOUBLE PRECISION, INTENT(INOUT) :: BESTUPPER
DOUBLE PRECISION, INTENT(OUT) :: LOWERBOUND, UPPERBOUND
INTEGER, INTENT(IN) :: IDNUM
LOGICAL, INTENT(IN) :: FORCE

DOUBLE PRECISION :: DIST2

CALL CALCBOUNDS(LOWERBOUND,UPPERBOUND,VECTOR,WIDTH,IDNUM,BESTUPPER,FORCE)

! If upperbound within tolerance of lowest upperbound then quench with
! minpermdist
IF ((UPPERBOUND).LE.(BESTUPPER + MPRTOL*BESTUPPER + ATOL)) THEN

    CALL ITERATIVEALIGN(SAVECOORDSB,DUMMYA,NATOMS,DEBUG,BOXLX,BOXLY,BOXLZ,BULKT, &
    & DIST2,UPPERBOUND,DUMMYRMAT,DUMMYDISP,PERMBEST)

    ! Resetting keywords
    NQUENCH = NQUENCH + 1

    IF(DEBUG) WRITE(MYUNIT, "(A,G20.5)") &
 & "gopermdist> post quench new lowest RMSD = ", UPPERBOUND
END IF

IF (UPPERBOUND.LT.BESTUPPER) THEN
    BESTUPPER = UPPERBOUND

    IF(DEBUG) WRITE(MYUNIT, "(A,G20.5)") &
 & "gopermdist> NEW lowest upper bound RMSD = ", UPPERBOUND

    IF (.NOT.BULKT) THEN
        BESTDISP(:,IDNUM) = DUMMYDISP
    ELSE
        BESTRMAT(:,:,IDNUM) = MATMUL(TRMAT,DUMMYRMAT)
    END IF

    BESTCOORDSA(:,IDNUM) = DUMMYA
    BESTPERMS(:,IDNUM) = PERMBEST
    BESTID = IDNUM
    BESTITER = NCALC
    CALL QUEUEPUT(LOWERBOUND,UPPERBOUND,VECTOR,WIDTH,NCALC,IDNUM)
ELSE IF( (LOWERBOUND ).LT.(BESTUPPER - RTOL*BESTUPPER - ATOL) ) THEN
    CALL QUEUEPUT(LOWERBOUND,UPPERBOUND,VECTOR,WIDTH,NCALC,IDNUM)
END IF

END SUBROUTINE ADDNODE


SUBROUTINE BRANCH(VECTOR,WIDTH,IDNUM,BESTUPPER,FORCE)

USE ALIGNUTILS, ONLY : TWOD

IMPLICIT NONE
DOUBLE PRECISION, INTENT(IN) :: VECTOR(3), WIDTH
DOUBLE PRECISION, INTENT(INOUT) :: BESTUPPER
INTEGER, INTENT(IN) :: IDNUM
LOGICAL, INTENT(IN) :: FORCE

DOUBLE PRECISION :: LOWERBOUND, UPPERBOUND, NEWVECT(3),MINR

INTEGER I

IF (BULKT.AND.TWOD) THEN
    ! If 2D then only need to test 4 search cubes
    DO I=1,4
        NEWVECT(:) = VECTOR + TWODVECS(:,I)*WIDTH*0.25D0
        ! Check if displacement is within lattice cell
        IF( ((BOXLX/2-ABS(NEWVECT(1))+WIDTH*0.25D0).GT.0.D0).AND. &
          & ((BOXLY/2-ABS(NEWVECT(2))+WIDTH*0.25D0).GT.0.D0) ) CALL ADDNODE( &
          & NEWVECT,WIDTH*0.5D0,IDNUM,BESTUPPER,FORCE,LOWERBOUND,UPPERBOUND)
    END DO
ELSE
    DO I=1,8
        NEWVECT(:) = VECTOR + LVECS(:,I)*WIDTH*0.25D0
        IF(BULKT) THEN
            ! Check if displacement is within lattice cell
            IF( ((BOXLX/2-ABS(NEWVECT(1))+WIDTH*0.25D0).GT.0.D0).AND. &
              & ((BOXLY/2-ABS(NEWVECT(2))+WIDTH*0.25D0).GT.0.D0).AND. &
              & ((BOXLZ/2-ABS(NEWVECT(2))+WIDTH*0.25D0).GT.0.D0) ) CALL ADDNODE( &
              & NEWVECT,WIDTH*0.5D0,IDNUM,BESTUPPER,FORCE,LOWERBOUND,UPPERBOUND)
        ! Check if rotation is within sphere
        ELSE IF ((SUM(NEWVECT**2)-0.75D0*WIDTH**2).LE.(PI**2)) THEN
            CALL ADDNODE(NEWVECT,WIDTH*0.5D0,IDNUM,BESTUPPER,FORCE,LOWERBOUND,UPPERBOUND)
        END IF
    END DO
END IF

END SUBROUTINE BRANCH

SUBROUTINE CALCBOUNDS(LOWERBOUND,UPPERBOUND,VECTOR,WIDTH,IDNUM,BESTUPPER,FORCE)

USE ALIGNUTILS, ONLY : PERMPAIRDISTS, FINDBESTPERM

IMPLICIT NONE
DOUBLE PRECISION, INTENT(IN) :: VECTOR(3), WIDTH, BESTUPPER
INTEGER, INTENT(IN) :: IDNUM
LOGICAL, INTENT(IN) :: FORCE

DOUBLE PRECISION, INTENT(OUT) :: LOWERBOUND, UPPERBOUND

DOUBLE PRECISION W,SINW,COSW,RA,RB,ESTLOWER,ESTUPPER,D,V,COSP
INTEGER I,J,J1,M,K,K1,IND,NDUMMY,NPERM,INFO,IA,IB
LOGICAL RECALC

!DOUBLE PRECISION PERMDIST

IF(BULKT) THEN
    W = SQRT(3.D0) * WIDTH * 0.5D0
ELSE
    V = SQRT(SUM(VECTOR**2))
    COSP = V/SQRT(V**2 + 0.75*WIDTH**2)
    !COSP = (V-WIDTH*0.5D0)/SQRT(V**2 - V*WIDTH + 0.5*WIDTH**2)
    COSW = MIN(COS(WIDTH*0.5D0), (COS(V)**2 + COSP*SIN(V)**2) * COS(WIDTH*0.5D0) - &
     & (1-COSP)*ABS(SIN(V)*COS(V)*SIN(WIDTH*0.5D0)) )
!    COSW = COS(W)
    SINW = SQRT(1.D0 - COSW**2)
END IF

IF(DEBUG) THEN
    IF(BULKT) WRITE(MYUNIT, "(A,3F16.5)") &
 & "gopermdist> testing displacement vector = ", VECTOR
    IF(.NOT.BULKT) WRITE(MYUNIT, "(A,3F16.5)") &
 & "gopermdist> testing angle-axis vector   = ", VECTOR
    WRITE(MYUNIT, "(A,G20.5,A,I4)") &
 & "gopermdist> with width                  = ", WIDTH, &
 & "     on IDNUM    =", IDNUM
END IF

CALL TRANSFORM(DUMMYA, NATOMS, VECTOR, IDNUM)

! Find distance matrix

CALL PERMPAIRDISTS(SAVECOORDSB,DUMMYA,NATOMS,PMAXNEI,DUMMYDISTS,DUMMYIDX,NPERMGROUP)

! Find bounded distanace matrix
IF(BULKT) THEN
    NDUMMY=0
    DO J1=1,NPERMGROUP
        NPERM=NPERMSIZE(J1)
        M = MIN(NPERM,PMAXNEI)
        DUMMYLDISTS(:NPERM*M,J1) = MAX(SQRT(DUMMYDISTS(:NPERM*M,J1)) - W,0.D0)**2
    ENDDO
ELSE
    NDUMMY=0
    DO J1=1,NPERMGROUP
        NPERM = NPERMSIZE(J1)
        M = MIN(NPERM,PMAXNEI)
        DO J=1,NPERM
            K=M*(J-1)
            RB = SAVERB(PERMGROUP(J+NDUMMY))
            DO I=1,M
                IND = K+I
                RA = SAVERA(PERMGROUP(DUMMYIDX(IND,J1)+NDUMMY),IDNUM)
                DUMMYLDISTS(IND,J1) = BOUNDROTDISTANCE( &
                     & DUMMYDISTS(IND,J1),COSW,SINW,RB,RA)
            END DO
        ENDDO
    NDUMMY = NDUMMY + NPERMSIZE(J1)
    ENDDO
END IF

! Estimating upperbound by finding nearest neighbours
IF((.NOT.FORCE).OR.DEBUG) THEN
    CALL PERMNEARESTNEIGHBOURDISTS(DUMMYDISTS,DUMMYIDX,NATOMS,PMAXNEI, &
     & DUMMYNEARIDX,DUMMYNEARDISTS,NPERMGROUP)

    UPPERBOUND = SUM(DUMMYNEARDISTS)**0.5
    IF(DEBUG) WRITE(MYUNIT, "(A,G20.5,A)") &
 & "gopermdist> estimate for upper bound    = ", UPPERBOUND

    ! Check if permutation has been found anyway
    IF(UPPERBOUND.LT.BESTUPPER) THEN
        LPERM = 0
        DO J1=1,NATOMS
            LPERM(DUMMYNEARIDX(J1)) = 1
        END DO
        IF(ALL(LPERM.EQ.1)) THEN
            RECALC = .FALSE.
            IF(DEBUG) WRITE(MYUNIT, "(A)") &
 & "gopermdist> nearest neighbours are best permutation"
        ELSE
            RECALC = .TRUE.
        END IF
    ELSE
        RECALC = .FALSE.
    END IF
    ESTUPPER = UPPERBOUND
END IF


! Estimating Lower Bound by finding nearest neighbours
IF(DEBUG.OR.(.NOT.(FORCE.OR.RECALC))) THEN
    IF(BULKT) THEN

        ! Find relative displacements
        DO J1=1,NPERMGROUP
            NPERM=NPERMSIZE(J1)
            M = MIN(NPERM,PMAXNEI)
            DO I=1,NPERM
                IB = PERMGROUP(I+NDUMMY)
                K = M*(I-1)
                DO J=1,M
                    IA = PERMGROUP(DUMMYIDX(K+J,J1)+NDUMMY)
                    DUMMYDISPS(:,K+J,J1) = SAVECOORDSB(3*IB-2:3*IB) - DUMMYA(3*IA-2:3*IA)
                    DUMMYDISPS(1,K+J,J1) = DUMMYDISPS(1,K+J,J1) - &
                     & NINT(DUMMYDISPS(1,K+J,J1)/BOXLX) * BOXLX
                    DUMMYDISPS(2,K+J,J1) = DUMMYDISPS(2,K+J,J1) - &
                     & NINT(DUMMYDISPS(2,K+J,J1)/BOXLY) * BOXLY
                    DUMMYDISPS(3,K+J,J1) = DUMMYDISPS(3,K+J,J1) - &
                     & NINT(DUMMYDISPS(3,K+J,J1)/BOXLZ) * BOXLZ

                    DUMMYDOTDISP(:,K+J,J1) = MATMUL(DUMMYDISPS(:,K+J,J1),LVECS(:,1:4))
                END DO
            END DO
            NDUMMY = NDUMMY + NPERM
        END DO

        ESTLOWER = HUGE(1.D0)
        DO I=1,6
            DO J1=1,NPERMGROUP
                NPERM=NPERMSIZE(J1)
                M = MIN(NPERM,PMAXNEI)
                DUMMYLDISTS2(:M*NPERM,J1) = MERGE(DUMMYDISTS(:M*NPERM,J1), &
                                                & DUMMYLDISTS(:M*NPERM,J1), &
                 & MATMUL(FVECS(:,I),DUMMYDOTDISP(:,:M*NPERM,J1)).GT.0.D0)
            END DO

            CALL PERMNEARESTNEIGHBOURDISTS(DUMMYLDISTS2,DUMMYIDX,NATOMS, &
             & PMAXNEI,DUMMYNEARIDX,DUMMYNEARLDISTS,NPERMGROUP)

            D = SUM(DUMMYNEARLDISTS)
            ESTLOWER = MIN(D, ESTLOWER)

            IF(DEBUG) WRITE(MYUNIT, "(A,I16,A,G10.5)") &
     & "gopermdist> estimating for face         = ", I, &
     & "         lower bound = ", D**0.5
        END DO
        ESTLOWER = SQRT(ESTLOWER)

    ELSE
        CALL PERMNEARESTNEIGHBOURDISTS(DUMMYLDISTS,DUMMYIDX,NATOMS,PMAXNEI, &
         & DUMMYNEARIDX,DUMMYNEARLDISTS,NPERMGROUP)

        ESTLOWER = SUM(DUMMYNEARLDISTS)**0.5
    END IF

    LOWERBOUND = ESTLOWER

    IF(DEBUG) WRITE(MYUNIT, "(A,G20.5)") &
     & "gopermdist> estimate for lower bound    = ", ESTLOWER

END IF


! If estimate of upperbound is lower than best found upperbound we need to
! solve assignment problem to find bounds
IF (FORCE.OR.RECALC) THEN

    ! Need to calculate this matrix to get total distance from reduced distance
    ! matrix and total permutation
    CALL INVPAIRDISTIDX(DUMMYIDX, DINVIDX, NATOMS, PMAXNEI, NPERMGROUP)

    IF(BULKT) THEN
        DO J1=1,NPERMGROUP
            NPERM=NPERMSIZE(J1)
            M = MIN(NPERM,PMAXNEI)
            DUMMYLDISTS(:NPERM*M,J1) = MAX(SQRT(DUMMYDISTS(:NPERM*M,J1)) - W,0.D0)**2
        ENDDO
    END IF

    CALL FINDBESTPERM(DUMMYLDISTS,DUMMYIDX,NATOMS,PMAXNEI,NEWPERM, &
     & LOWERBOUND,NPERMGROUP, INFO)

    CALL FINDPERMVAL(NEWPERM,NATOMS,DUMMYLDISTS,DINVIDX,PMAXNEI,NPERMGROUP,LOWERBOUND)

    ! Check output of assignment problem
    IF(INFO.GT.0) THEN
        LOWERBOUND = 0.D0
        IF(DEBUG) WRITE(MYUNIT, "(A,I3)") &
 & "gopermdist> WARNING LAP algorithm failed to align npoints= ", INFO
    ELSE
        LOWERBOUND = SQRT(LOWERBOUND)
        IF(DEBUG) WRITE(MYUNIT, "(A,G20.5)") &
 & "gopermdist> calculated lower bound RMSD = ", LOWERBOUND
    END IF
    ! Calculate upperbound if lowerbound lower than bestupper
    IF((LOWERBOUND.LT.BESTUPPER).OR.FORCE) THEN
        CALL FINDBESTPERM(DUMMYDISTS,DUMMYIDX,NATOMS,PMAXNEI,LPERM, &
         & UPPERBOUND,NPERMGROUP, INFO)

        CALL FINDPERMVAL(LPERM,NATOMS,DUMMYDISTS,DINVIDX,PMAXNEI,NPERMGROUP,UPPERBOUND)

        ! Check output of assignment problem
        IF(INFO.GT.0) THEN
            UPPERBOUND = HUGE(1.D0)
            IF(DEBUG) WRITE(MYUNIT, "(A,I3)") &
 & "gopermdist> WARNING LAP algorithm failed to align npoints= ", INFO
        ELSE
            UPPERBOUND = SQRT(UPPERBOUND)
            IF(DEBUG) WRITE(MYUNIT, "(A,G20.5)") &
 & "gopermdist> calculated upper bound RMSD = ", UPPERBOUND
        END IF
    ELSE
        UPPERBOUND = HUGE(1.D0)
    END IF
END IF

IF (DEBUG.AND.((ESTUPPER.GT.UPPERBOUND).OR.(ESTLOWER.GT.LOWERBOUND))) THEN
    WRITE(MYUNIT,"(A)") "gopermdist>************WARNING*********************"
    WRITE(MYUNIT,"(A)") "EST UPPER GT UPPERBOUND OR EST LOWER GT LOWERBOUND"
    WRITE(MYUNIT,"(A)") "gopermdist>************WARNING*********************"
    NBAD = NBAD + 1
ENDIF

NCALC = NCALC + 1

END SUBROUTINE CALCBOUNDS

SUBROUTINE FINDPERMVAL(PERM, NATOMS, MATVALS, DINVIDX, MAXNEI, NPERMGROUP, BEST)

IMPLICIT NONE
INTEGER, INTENT(IN) :: PERM(NATOMS), NATOMS, DINVIDX(NATOMS*NATOMS,NPERMGROUP), &
 & MAXNEI, NPERMGROUP
DOUBLE PRECISION, INTENT(IN) :: MATVALS(NATOMS*MAXNEI,NPERMGROUP)
DOUBLE PRECISION, INTENT(OUT) :: BEST

INTEGER J1,M,J,I,IA,NPERM,NDUMMY

BEST = 0.D0
NDUMMY = 0
DO J1=1,NPERMGROUP
    NPERM = NPERMSIZE(J1)
    M = MIN(NPERM,MAXNEI)
    DO J=1,NPERM
        IA = INVPERMGROUP(PERM(PERMGROUP(J+NDUMMY)))-NDUMMY
        I = DINVIDX(NPERM*(J-1)+IA,J1)
        BEST = BEST + MATVALS(M*(J-1)+I,J1)
    END DO
    NDUMMY = NDUMMY + NPERM
END DO

END SUBROUTINE FINDPERMVAL

SUBROUTINE INVPAIRDISTIDX(DUMMYIDX, DINVIDX, NATOMS, MAXNEI, NPERMGROUP)

IMPLICIT NONE
INTEGER, INTENT(IN) :: DUMMYIDX(NATOMS*MAXNEI,NPERMGROUP), NATOMS, MAXNEI, NPERMGROUP
INTEGER, INTENT(OUT) :: DINVIDX(NATOMS*NATOMS,NPERMGROUP)
INTEGER J1,NPERM,I,J,M

DINVIDX = -1
DO J1=1,NPERMGROUP
    NPERM = NPERMSIZE(J1)
    M = MIN(NPERM,MAXNEI)
    DO J=1,NPERM
        DO I=1,M
            DINVIDX(NPERM*(J-1)+DUMMYIDX(M*(J-1)+I,J1),J1) = I
        END DO
    END DO
END DO

END SUBROUTINE INVPAIRDISTIDX

SUBROUTINE PERMNEARESTNEIGHBOURDISTS(NDISTS,NIDX,NATOMS,MAXNEI,NEARI,NEARD,NPERMGROUP)

IMPLICIT NONE
INTEGER, INTENT(IN) :: NATOMS,MAXNEI,NPERMGROUP,NIDX(MAXNEI*NATOMS,NPERMGROUP)
DOUBLE PRECISION, INTENT(IN) :: NDISTS(MAXNEI*NATOMS,NPERMGROUP)

INTEGER, INTENT(OUT) :: NEARI(NATOMS)
DOUBLE PRECISION, INTENT(OUT) :: NEARD(NATOMS)

INTEGER I, J1, J2, IND, NPERM, NDUMMY, M

NDUMMY = 0
DO J1=1,NPERMGROUP
    NPERM=NPERMSIZE(J1)
!    M = MERGE(NPERM,MAXNEI,NPERM.LT.MAXNEI)
    M = MIN(NPERM,PMAXNEI)
    CALL NEARESTNEIGHBOURDISTS(NDISTS(1:NPERM*M,J1),NIDX(1:NPERM*M,J1), &
 & NPERM,M,LPERM(1:NPERM),PDUMMYND(1:NPERM))

    DO J2=1,NPERM
        IND = LPERM(J2)
        NEARI(PERMGROUP(NDUMMY+J2)) = PERMGROUP(NDUMMY + IND)
        NEARD(PERMGROUP(NDUMMY+J2)) = PDUMMYND(J2)
    END DO
    NDUMMY = NDUMMY + NPERM
END DO

END SUBROUTINE PERMNEARESTNEIGHBOURDISTS

SUBROUTINE NEARESTNEIGHBOURDISTS(CC, KK, N, MAXNEI, IDX, DISTS)

IMPLICIT NONE

INTEGER, INTENT(IN) :: N, MAXNEI, KK(MAXNEI*N)
DOUBLE PRECISION, INTENT(IN) :: CC(MAXNEI*N)

INTEGER, INTENT(OUT) :: IDX(N)
DOUBLE PRECISION, INTENT(OUT) :: DISTS(N)

INTEGER I,J,K,M

M=MAXNEI
IF(N.LT.MAXNEI) M=N

DO I=1,N
    J = MINLOC(CC(M*(I-1)+1:M*I),1)
    DISTS(I) = CC(M*(I-1) + J)
    IDX(I)   = KK(M*(I-1) + J)
END DO

END SUBROUTINE NEARESTNEIGHBOURDISTS

FUNCTION BOUNDROTDISTANCE(D2,COSW,SINW,RA,RB) RESULT(LDIST)

IMPLICIT NONE
DOUBLE PRECISION, INTENT(IN) :: D2,COSW,SINW,RA,RB
DOUBLE PRECISION LDIST

DOUBLE PRECISION RARB,RA2RB2,COSAB,SINAB,MCOSAB

! Precalculate these?
RARB = 2*RA*RB
RA2RB2 = RA**2 + RB**2

COSAB = (RA2RB2 - D2)/RARB
SINAB = SQRT(1.D0-MIN(COSAB**2,1.D0)) ! Making sure sqrt is of positive number
MCOSAB = MERGE(1.D0, COSAB*COSW + SINAB*SINW, COSAB.GT.COSW)

LDIST = MAX(RA2RB2 - RARB*MCOSAB,0.D0)

END FUNCTION

FUNCTION QUEUELEN() RESULT(LENGTH)

IMPLICIT NONE
INTEGER LENGTH

LENGTH = Q%N

END FUNCTION

SUBROUTINE QUEUEGET(LOWERBOUND, UPPERBOUND, VECTOR, WIDTH, NITER, IDNUM)
USE PRIORITYQUEUE, ONLY: NODE, TOP

IMPLICIT NONE
DOUBLE PRECISION, INTENT(OUT) :: lowerbound, upperbound, vector(3), width
INTEGER, INTENT(OUT) :: niter, IDNUM

TYPE(NODE) RES

IF(Q%N.GT.0) THEN
    RES = TOP(Q)
    VECTOR = RES%VECTOR
    UPPERBOUND = RES%UPPERBOUND
    LOWERBOUND = RES%LOWERBOUND
    WIDTH = RES%WIDTH
    NITER = RES%NITER
    IDNUM = RES%IDNUM
ELSE IF(DEBUG) THEN
    WRITE(MYUNIT,"(A)") "gopermdist> warning, trying to read empty list"
ENDIF

END SUBROUTINE QUEUEGET

SUBROUTINE QUEUEPUT(LOWERBOUND, UPPERBOUND, VECTOR, WIDTH, NITER, IDNUM)
USE PRIORITYQUEUE, ONLY: ENQUEUE

IMPLICIT NONE

DOUBLE PRECISION, INTENT(IN) :: lowerbound, upperbound, vector(3), width
INTEGER, INTENT(IN) :: niter, IDNUM

CALL ENQUEUE(Q, LOWERBOUND, UPPERBOUND, VECTOR, WIDTH, NITER, IDNUM)

END SUBROUTINE QUEUEPUT

SUBROUTINE QUEUECLEAR()
USE PRIORITYQUEUE, ONLY: NODE, TOP

IMPLICIT NONE
TYPE(NODE) RES

DO WHILE(Q%N.GT.0)
    RES = TOP(Q)
END DO

END SUBROUTINE QUEUECLEAR

SUBROUTINE INITIALISE(COORDSB,COORDSA,NATOMS,NBOXLX,NBOXLY,NBOXLZ,NBULKT)

USE ALIGNUTILS, ONLY: OHOPS

IMPLICIT NONE

INTEGER, INTENT(IN) :: NATOMS
DOUBLE PRECISION, INTENT(IN) :: COORDSB(3*NATOMS), COORDSA(3*NATOMS), &
 & NBOXLX, NBOXLY, NBOXLZ
LOGICAL, INTENT(IN) :: NBULKT

DOUBLE PRECISION BVEC(3)
INTEGER I, J, K, IND, NUMSTRUCTS

BOXLX = NBOXLX
BOXLY = NBOXLY
BOXLZ = NBOXLZ
BOXVEC = (/BOXLX,BOXLY,BOXLZ/)
BULKT = NBULKT

NCALC   = 0
NLAP    = 0
NQUENCH = 0
NBAD = 0

! --------------------------------------------------------------------------- !
!    allocating memory to arrays
! --------------------------------------------------------------------------- !

NUMSTRUCTS = 1
IF (PERMINVOPT.AND.(.NOT.BULKT)) NUMSTRUCTS = 2
IF (BULKT.AND.OHCELLT) NUMSTRUCTS = 48


CALL REALLOCATEARRAYS(NATOMS, NUMSTRUCTS, BULKT)

! --------------------------------------------------------------------------- !
!    calculate inverse permutation group
! --------------------------------------------------------------------------- !

DO I=1,NATOMS
    INVPERMGROUP(PERMGROUP(I)) = I
END DO

! --------------------------------------------------------------------------- !
!    storing coordinates to module
! --------------------------------------------------------------------------- !

IF(BULKT) THEN
    SAVECOORDSB = COORDSB
    IF(OHCELLT) THEN
        DO I=1,48
            CALL OHOPS(COORDSA,SAVECOORDSA(:,I),I,NATOMS)
        END DO
    ELSE
        SAVECOORDSA(:,1) = COORDSA
    END IF
ELSE
    ! Calculate COM
    DO J=1,NATOMS
        CMAX=CMAX+COORDSA(3*(J-1)+1)
        CMAY=CMAY+COORDSA(3*(J-1)+2)
        CMAZ=CMAZ+COORDSA(3*(J-1)+3)
    ENDDO
    CMAX=CMAX/NATOMS; CMAY=CMAY/NATOMS; CMAZ=CMAZ/NATOMS
    CMBX=0.0D0; CMBY=0.0D0; CMBZ=0.0D0
    DO J=1,NATOMS
        CMBX=CMBX+COORDSB(3*(J-1)+1)
        CMBY=CMBY+COORDSB(3*(J-1)+2)
        CMBZ=CMBZ+COORDSB(3*(J-1)+3)
    ENDDO
    CMBX=CMBX/NATOMS; CMBY=CMBY/NATOMS; CMBZ=CMBZ/NATOMS

    ! Save COM centred coordinates
    DO I=1,NATOMS
        SAVECOORDSB(3*I-2) = COORDSB(3*I-2) - CMBX
        SAVECOORDSB(3*I-1) = COORDSB(3*I-1) - CMBY
        SAVECOORDSB(3 * I) = COORDSB(3 * I) - CMBZ
        SAVERB(I) = SQRT(SAVECOORDSB(3*I-2)**2+SAVECOORDSB(3*I-1)**2+ &
                       & SAVECOORDSB(3 * I)**2)
    ENDDO
    DO I=1,NATOMS
        SAVECOORDSA(3*I-2,1) = COORDSA(3*I-2) - CMAX
        SAVECOORDSA(3*I-1,1) = COORDSA(3*I-1) - CMAY
        SAVECOORDSA(3 * I,1) = COORDSA(3 * I) - CMAZ
        SAVERA(I,1) = SQRT(SAVECOORDSA(3*I-2,1)**2+SAVECOORDSA(3*I-1,1)**2+ &
                         & SAVECOORDSA(3 * I,1)**2)
    ENDDO
    ! Store inverted configuration
    IF (PERMINVOPT) THEN
        SAVECOORDSA(:,2) = -SAVECOORDSA(:,1)
        SAVERA(:,2) = SAVERA(:,1)
    END IF
END IF

CALL QUEUECLEAR()

END SUBROUTINE INITIALISE

SUBROUTINE SETNATOMS(NEWNATOMS)
! Checks if arrays need to be (re)allocated
IMPLICIT NONE

INTEGER, INTENT(IN) :: NEWNATOMS

IF(.NOT.(SIZE(PDUMMYA).EQ.(3*NEWNATOMS))) THEN
    IF(ALLOCATED(PDUMMYA)) THEN
        DEALLOCATE(PDUMMYA,PDUMMYB,DUMMYA,DUMMYB,XBESTA,XBESTASAVE)
        DEALLOCATE(NEWPERM, LPERM)
    ENDIF
    ALLOCATE(PDUMMYA(3*NEWNATOMS),PDUMMYB(3*NEWNATOMS),DUMMYA(3*NEWNATOMS), &
    &   DUMMYB(3*NEWNATOMS), XBESTA(3*NEWNATOMS), XBESTASAVE(3*NEWNATOMS))
    ALLOCATE(NEWPERM(NEWNATOMS), LPERM(NEWNATOMS))
ENDIF

END SUBROUTINE SETNATOMS

SUBROUTINE SETPERM(NEWNATOMS, NEWPERMGROUP, NEWNPERMSIZE)
! Not needed for GMIN/OPTIM/PATHSAMPLE
! (Re)allocates arrays that define allowed permuations
IMPLICIT NONE

INTEGER, INTENT(IN) :: NEWNATOMS, NEWPERMGROUP(:), NEWNPERMSIZE(:)

IF(.NOT.SIZE(PERMGROUP).EQ.SIZE(NEWPERMGROUP)) THEN
    IF(ALLOCATED(PERMGROUP)) THEN
        DEALLOCATE(PERMGROUP)
    ENDIF
    ALLOCATE(PERMGROUP(SIZE(NEWPERMGROUP)))
ENDIF

NPERMGROUP = SIZE(NEWNPERMSIZE)
IF(.NOT.SIZE(NPERMSIZE).EQ.SIZE(NEWNPERMSIZE)) THEN
    IF(ALLOCATED(NPERMSIZE)) THEN
        DEALLOCATE(NPERMSIZE)
    ENDIF
    ALLOCATE(NPERMSIZE(NPERMGROUP))
ENDIF

IF(.NOT.SIZE(BESTPERM).EQ.NEWNATOMS) THEN
    IF(ALLOCATED(BESTPERM)) THEN
        DEALLOCATE(BESTPERM)
    ENDIF
    ALLOCATE(BESTPERM(NEWNATOMS))
ENDIF

IF(.NOT.SIZE(NSETS).EQ.(3*NEWNATOMS)) THEN
    IF(ALLOCATED(NSETS)) THEN
        DEALLOCATE(NSETS)
    ENDIF
    ALLOCATE(NSETS(3*NEWNATOMS))
ENDIF

IF(.NOT.SIZE(SETS).EQ.(3*NEWNATOMS*70)) THEN
    IF(ALLOCATED(SETS)) THEN
        DEALLOCATE(SETS)
    ENDIF
    ALLOCATE(SETS(3*NEWNATOMS,70))
ENDIF

CALL SETNATOMS(NEWNATOMS)

NATOMS = NEWNATOMS
PERMGROUP = NEWPERMGROUP
NPERMSIZE = NEWNPERMSIZE
NSETS = 0

END SUBROUTINE SETPERM

SUBROUTINE TRANSFORM(NEWCOORDSA, NATOMS, VECTOR, IDNUM)

IMPLICIT NONE
INTEGER, INTENT(IN) :: NATOMS, IDNUM
DOUBLE PRECISION, INTENT(IN) :: VECTOR(3)

DOUBLE PRECISION, INTENT(OUT) :: NEWCOORDSA(3*NATOMS)

INTEGER I

IF(BULKT) THEN
    DO I=1,NATOMS
        NEWCOORDSA(3*I-2) = SAVECOORDSA(3*I-2,IDNUM) - VECTOR(1)
        NEWCOORDSA(3*I-1) = SAVECOORDSA(3*I-1,IDNUM) - VECTOR(2)
        NEWCOORDSA(3*I  ) = SAVECOORDSA(3*I  ,IDNUM) - VECTOR(3)
    ENDDO
ELSE
    CALL ANGLEAXIS2MAT(VECTOR, TRMAT)
    DO I=1,NATOMS
        NEWCOORDSA(3*I-2:3*I) = MATMUL(TRMAT,SAVECOORDSA(3*I-2:3*I,IDNUM))
    ENDDO
ENDIF

END SUBROUTINE TRANSFORM

SUBROUTINE ANGLEAXIS2MAT(VECTOR,RMAT)

IMPLICIT NONE
DOUBLE PRECISION, INTENT(IN) :: VECTOR(3)
DOUBLE PRECISION, INTENT(OUT) :: RMAT(3,3)

DOUBLE PRECISION THETA,X,Y,Z,S,C,C1,XS,YS,ZS,XC,YC,ZC,XYC,YZC,ZXC

THETA = SUM((VECTOR**2))**0.5

IF(THETA.EQ.0.D0) THEN
    RMAT = RESHAPE((/&
     & 1.00000000000D0,  0.0D0,  0.0D0,   &
     & 0.0D0,  1.00000000000D0,  0.0D0,   &
     & 0.0D0,  0.0D0,  1.00000000000D0/), (/3,3/))
ELSE
    X = VECTOR(1)/THETA; Y = VECTOR(2)/THETA; Z = VECTOR(3)/THETA
    S = SIN(THETA); C = COS(THETA); C1 = 1.D0 - C
    XS = X*S; YS = Y*S; ZS = Z*S
    XC = X*C1; YC = Y*C1; ZC = Z*C1
    XYC = X*YC; YZC = Y*ZC; ZXC = Z*XC

    RMAT = RESHAPE((/&
     & x * xC + c, xyC + zs, zxC - ys, &
     & xyC - zs, y * yC + c, yzC + xs, &
     & zxC + ys, yzC - xs, z * zC + c/), (/3,3/))
END IF

END SUBROUTINE ANGLEAXIS2MAT

SUBROUTINE MAT2ANGLEAXIS(VECTOR, RMAT)

IMPLICIT NONE
DOUBLE PRECISION, INTENT(OUT) :: VECTOR(3)
DOUBLE PRECISION, INTENT(IN) :: RMAT(0:2,0:2)

DOUBLE PRECISION TRACE, THETA

TRACE = RMAT(0,0)+RMAT(1,1)+RMAT(2,2)
THETA = ACOS(0.5D0*TRACE-0.5D0)
VECTOR = (/RMAT(2,1)-RMAT(1,2),RMAT(0,2)-RMAT(2,0),RMAT(1,0)-RMAT(0,1)/)
VECTOR = VECTOR * 0.5D0 * THETA / SIN(THETA)

END SUBROUTINE MAT2ANGLEAXIS

SUBROUTINE REALLOCATEARRAYS(NATOMS, NUMSTRUCTS, BULKT)

IMPLICIT NONE

INTEGER, INTENT(IN) :: NATOMS, NUMSTRUCTS
LOGICAL, INTENT(IN) :: BULKT

IF((.NOT.ALLOCATED(PERMGROUP)).OR.(.NOT.ALLOCATED(NPERMSIZE))) THEN
    WRITE(*,'(A)') 'ERROR - permutation arrays not set, use PERMOPT keyword'
    STOP
ENDIF

CALL SETNATOMS(NATOMS)

IF (SIZE(SAVECOORDSA).NE.(3*NATOMS*NUMSTRUCTS)) THEN
    IF(ALLOCATED(SAVECOORDSB))  DEALLOCATE(SAVECOORDSB,SAVECOORDSA)
    IF(ALLOCATED(SAVERA)) DEALLOCATE(SAVERA,SAVERB,BESTCOORDSA,BESTRMAT, &
     & BESTDISP,BESTITERS,BESTPERMS)
    ALLOCATE(SAVECOORDSB(3*NATOMS),SAVECOORDSA(3*NATOMS,NUMSTRUCTS), &
     & SAVERB(NATOMS),SAVERA(NATOMS,NUMSTRUCTS),BESTCOORDSA(3*NATOMS,NUMSTRUCTS), &
     & BESTRMAT(3,3,NUMSTRUCTS),BESTDISP(3,NUMSTRUCTS),BESTITERS(NUMSTRUCTS), &
     & BESTPERMS(NATOMS,NUMSTRUCTS))
END IF

IF (SIZE(PDUMMYA).NE.(3*NATOMS)) THEN
    IF(ALLOCATED(PDUMMYA)) DEALLOCATE(PDUMMYA,PDUMMYB,DUMMYA,DUMMYB)
    ALLOCATE(PDUMMYA(3*NATOMS),PDUMMYB(3*NATOMS),DUMMYA(3*NATOMS), &
     & DUMMYB(3*NATOMS))
END IF

IF (SIZE(DUMMYLDISTS).NE.(PMAXNEI*NATOMS*NPERMGROUP)) THEN
    IF(ALLOCATED(DUMMYDISTS)) DEALLOCATE(DUMMYDISTS, DUMMYIDX)
    IF(ALLOCATED(DUMMYNEARDISTS)) DEALLOCATE(DUMMYNEARDISTS,DINVIDX,DUMMYNEARIDX, &
     & DUMMYLDISTS,DUMMYNEARLDISTS, DUMMYLDISTS2,DUMMYDOTDISP,DUMMYDISPS,PDUMMYND)
    ALLOCATE(DUMMYDISTS(PMAXNEI*NATOMS,NPERMGROUP),DUMMYNEARDISTS(NATOMS), &
     & PDUMMYND(NATOMS),DUMMYIDX(PMAXNEI*NATOMS,NPERMGROUP),DUMMYNEARIDX(NATOMS), &
     & DINVIDX(NATOMS*NATOMS,NPERMGROUP),DUMMYLDISTS(PMAXNEI*NATOMS,NPERMGROUP), &
     & DUMMYNEARLDISTS(NATOMS),DUMMYLDISTS2(PMAXNEI*NATOMS,NPERMGROUP), &
     & DUMMYDISPS(3,NATOMS*PMAXNEI,NPERMGROUP),DUMMYDOTDISP(4,NATOMS*PMAXNEI,NPERMGROUP))
END IF

IF (SIZE(INVPERMGROUP).NE.(NATOMS)) THEN
    IF(ALLOCATED(NEWPERM)) DEALLOCATE(NEWPERM,LPERM)
    IF(ALLOCATED(INVPERMGROUP)) DEALLOCATE(INVPERMGROUP, PERMBEST)
    ALLOCATE(NEWPERM(NATOMS), LPERM(NATOMS), PERMBEST(NATOMS), INVPERMGROUP(NATOMS))
END IF

END SUBROUTINE REALLOCATEARRAYS

SUBROUTINE DEALLOCATEBNB()

IMPLICIT NONE

IF(ALLOCATED(SAVECOORDSB))  DEALLOCATE(SAVECOORDSB,SAVECOORDSA)
IF(ALLOCATED(SAVERA)) DEALLOCATE(SAVERA,SAVERB,BESTCOORDSA,BESTRMAT, &
 & BESTDISP,BESTITERS,BESTPERMS)
IF(ALLOCATED(PDUMMYA)) DEALLOCATE(PDUMMYA,PDUMMYB,DUMMYA,DUMMYB)
IF(ALLOCATED(DUMMYDISTS)) DEALLOCATE(DUMMYDISTS, DUMMYIDX)
IF(ALLOCATED(DUMMYNEARDISTS)) DEALLOCATE(DUMMYNEARDISTS,DINVIDX,DUMMYNEARIDX, &
 & DUMMYLDISTS,DUMMYNEARLDISTS, DUMMYLDISTS2,DUMMYDOTDISP,DUMMYDISPS,PDUMMYND)

END SUBROUTINE DEALLOCATEBNB

SUBROUTINE SETCLUSTER(INVERT)

IMPLICIT NONE
LOGICAL, INTENT(IN) :: INVERT

MYUNIT = 6
PERMINVOPT = INVERT
NOINVERSION = .NOT.INVERT

END SUBROUTINE SETCLUSTER

SUBROUTINE SETBULK(INVERT)

IMPLICIT NONE
LOGICAL, INTENT(IN) :: INVERT

MYUNIT = 6
PERMINVOPT = .FALSE.
OHCELLT = INVERT

END SUBROUTINE SETBULK

END MODULE
